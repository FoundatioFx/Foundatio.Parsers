﻿@namespace Exceptionless.LuceneQueryParser
@classname QueryParser
@using System.Linq;
@using Exceptionless.LuceneQueryParser.Nodes;

start<GroupNode>
  = _* node:node
    {
        node
    }
  / _* EOF
    {
        new GroupNode()
    }
  / #ERROR{ "Unable to parse query." }

node<GroupNode>
  = op:operator_exp EOF
    {
        new GroupNode {
            Operator = op
        }
    }
  / op:operator_exp right:node
    {
        right
    }
  / left:group_exp op:(operator_exp* "") right:node*
    {{
        var node= new GroupNode {
            Left = left
        };

        var rightExp =
                right.Count == 0
                ? (TermNode)null
                : right[0].Right == null
                    ? right[0].Left
                    : right[0];

        if (rightExp != null)
        {
            node.Operator = !String.IsNullOrEmpty(op) ? op.Trim() : null;
            node.Right = rightExp;
        }

        return node;
    }}

group_exp<IQueryNode>
  = field_exp:field_exp _*
    {
        field_exp
    }
  / paren_exp

paren_exp<GroupNode>
  = "(" node:node ")" _*
    {{
        node.HasParens = true;
        return node;
    }}

field_exp<IQueryNode>
  = name:fieldname? range:range_operator_exp
    {{
        range.Field = name.Count > 0 ? name[0] : null;

        return range;
    }}
  / name:fieldname node:paren_exp
    {{
        node.Field = name;
        return node;
    }}
  / name:fieldname? term:term
    {{
        var query = new TermNode {
            Field = name.Count > 0 ? name[0] : null
        };

        term.CopyTo(query);

        return query;
    }}

fieldname<FieldExpressionNode>
  = op:prefix_operator_exp? fieldname:name_term ':'
      {{
        var result = new FieldExpressionNode { Field = fieldname };

        result.Prefix = op.SingleOrDefault();

        return result;
    }}

term<TermNode>
  = op:prefix_operator_exp? term:quoted_term proximity:proximity_modifier? boost:boost_modifier? _*
      {{
        var result = new TermNode { Term = term, IsQuotedTerm = true };

        if (proximity.Count > 0)
            result.Proximity = proximity.SingleOrDefault();

        if (boost.Count > 0)
            result.Boost = boost.SingleOrDefault();

        result.Prefix = op.SingleOrDefault();

        return result;
    }}
  / op:prefix_operator_exp? term:unquoted_term proximity:proximity_modifier? boost:boost_modifier? _*
    {{
        var result = new TermNode { Term = term };

        if (proximity.Count > 0)
            result.Proximity = proximity.SingleOrDefault();

        if (boost.Count > 0)
            result.Boost = boost.SingleOrDefault();

        result.Prefix = op.SingleOrDefault();

        return result;
    }}

name_term
  = term:([^: \t\r\n\f\{\}\(\)"/^~\[\]]+ "")
    {
        term
    }

unquoted_term
  = term:([^: \t\r\n\f\{\}\(\)/^~\[\]]+ "")
    {
        term
    }

range_unquoted_term
  = term:([^: \.\t\r\n\f\{\}\(\)"^~\[\]]+ "")
    {
        term
    }

quoted_term
  = '"' term:([^"]+ "") '"'
    {
        term
    }

boost_modifier<double>
  = '^' boost:decimal_or_int_exp
    {
        boost
    }

proximity_modifier<double>
  = '~' proximity:(decimal_or_int_exp? "")
    {
        String.IsNullOrEmpty(proximity) ? Double.MinValue : Double.Parse(proximity)
    }

decimal_or_int_exp<double>
 = decimal_exp
 / int_exp

decimal_exp<double>
 = '0.' val:([0-9]+ "")
    {
        Double.Parse("0." + val)
    }

int_exp<double>
  = val:([0-9]+ "")
    {      
        Double.Parse(val)
    }

range_operator_exp<TermNode>
  = '[' term_min:range_unquoted_term delim:range_delimiter_exp term_max:range_unquoted_term ']'
    {
        new TermNode {
            TermMin = term_min,
            TermMax = term_max,
            MinInclusive = true,
            MaxInclusive = true,
            TermDelimiter = delim
        }
    }
  / '{' term_min:range_unquoted_term delim:range_delimiter_exp term_max:range_unquoted_term '}'
    {
        new TermNode {
            TermMin = term_min,
            TermMax = term_max,
            MinInclusive = false,
            MaxInclusive = false,
            TermDelimiter = delim
        }
    }
  / '{' term_min:range_unquoted_term delim:range_delimiter_exp term_max:range_unquoted_term ']'
    {
        new TermNode {
            TermMin = term_min,
            TermMax = term_max,
            MinInclusive = false,
            MaxInclusive = true,
            TermDelimiter = delim
        }
    }
  / '[' term_min:range_unquoted_term delim:range_delimiter_exp term_max:range_unquoted_term '}'
    {
        new TermNode {
            TermMin = term_min,
            TermMax = term_max,
            MinInclusive = true,
            MaxInclusive = false,
            TermDelimiter = delim
        }
    }

range_delimiter_exp
  = _+ 'TO' _+
  / _* '..' _*

operator_exp
  = _* op:operator _+
    {
        op
    }
  / _* op:operator EOF
    {
        op
    }

operator
  = "OR"
  / "AND"
  / "NOT"
  / "||" { "OR" }
  / "&&" { "AND" }

prefix_operator_exp
  = _* op:prefix_operator
    {
        op
    }

prefix_operator
  = '+'
  / '-'

_
  = [ \t\r\n\f]+

EOF
  = !.
