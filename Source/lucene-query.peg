﻿@namespace Exceptionless.LuceneQueryParser
@classname QueryParser
@using System.Linq;
@using Exceptionless.LuceneQueryParser.Nodes;

@members
{
    public class FieldInfo {
        public string Field { get; set; }
        public string Prefix { get; set; }
    }
}

start<GroupNode>
  = _* node:node
    {
        node
    }
  / _* EOF
    {
        new GroupNode()
    }
  / #ERROR{ "Unable to parse query." }

node<GroupNode>
  = op:operator_exp EOF
    {
        new GroupNode {
            Operator = op
        }
    }
  / op:operator_exp right:node
    {
        right
    }
  / left:group_exp op:operator_exp? right:node*
    {{
        var node= new GroupNode {
            Left = left
        };

        var rightExp =
                right.Count == 0
                ? (TermNode)null
                : right[0].Right == null
                    ? right[0].Left
                    : right[0];

        if (rightExp != null)
        {
            node.Operator = op.SingleOrDefault();
            node.Right = rightExp;
        }

        return node;
    }}

group_exp<IQueryNode>
  = field_exp:field_exp _*
    {
        field_exp
    }
  / paren_exp

paren_exp<GroupNode>
  = "(" node:node ")" boost:boost_modifier? _*
    {{
        node.HasParens = true;

        if (boost.Count > 0)
            node.Boost = boost.SingleOrDefault();

        return node;
    }}

field_exp<IQueryNode>
  = op:prefix_operator_exp? '_exists_' _* ':' _* fieldname:name_term
  {{
        return new ExistsNode { Prefix = op.SingleOrDefault(), Field = fieldname };
  }}
  / op:prefix_operator_exp? '_missing_' _* ':' _* fieldname:name_term
  {{
        return new MissingNode { Prefix = op.SingleOrDefault(), Field = fieldname };
  }}
  / name:fieldname? range:range_operator_exp
    {{
        if (name.Count == 1) {
          range.Field = name[0].Field;
          range.Prefix = name[0].Prefix;
        }

        return range;
    }}
  / op:prefix_operator_exp? range:range_operator_exp
    {{
        range.Prefix = op.SingleOrDefault();
        return range;
    }}
  / name:fieldname node:paren_exp
    {{
        node.Field = name.Field;
        node.Prefix = name.Prefix;
        return node;
    }}
  / name:fieldname? term:term
    {{
        var query = new TermNode();

        if (name.Count == 1) {
          query.Field = name[0].Field;
          query.Prefix = name[0].Prefix;
        }

        term.CopyTo(query);

        return query;
    }}

fieldname<FieldInfo> -lexical
  = op:prefix_operator_exp? fieldname:name_term _* ':' _*
      {{
        var result = new FieldInfo { Field = fieldname };

        result.Prefix = op.SingleOrDefault();

        return result;
    }}

term<TermNode>
  = op:prefix_operator_exp? term:quoted_term proximity:proximity_modifier? boost:boost_modifier? _*
      {{
        var result = new TermNode { Term = term, IsQuotedTerm = true };

        if (proximity.Count > 0)
            result.Proximity = proximity.SingleOrDefault();

        if (boost.Count > 0)
            result.Boost = boost.SingleOrDefault();

        result.Prefix = op.SingleOrDefault();

        return result;
    }}
  / op:prefix_operator_exp? term:unquoted_term proximity:proximity_modifier? boost:boost_modifier? _*
    {{
        var result = new TermNode { Term = term };

        if (proximity.Count > 0)
            result.Proximity = proximity.SingleOrDefault();

        if (boost.Count > 0)
            result.Boost = boost.SingleOrDefault();

        result.Prefix = op.SingleOrDefault();

        return result;
    }}

name_term
  = term:([^: \t\r\n\f\{\}\(\)"/^~\[\]]+ "")
    {
        term
    }

unquoted_term
  = term:([^: \t\r\n\f\{\}\(\)/^~\[\]]+ "")
    {
        term
    }

range_unquoted_term
  = term:([^: \.\t\r\n\f\{\}\(\)"^~\[\]]+ "")
    {
        term
    }

quoted_term
  = '"' term:([^"]+ "") '"'
    {
        term
    }

boost_modifier<double>
  = '^' boost:decimal_or_int_exp
    {
        boost
    }

proximity_modifier<double>
  = '~' proximity:(decimal_or_int_exp? "")
    {
        String.IsNullOrEmpty(proximity) ? Double.MinValue : Double.Parse(proximity)
    }

decimal_or_int_exp<double>
 = decimal_exp
 / int_exp

decimal_exp<double>
 = '0.' val:([0-9]+ "")
    {
        Double.Parse("0." + val)
    }

int_exp<double>
  = val:([0-9]+ "")
    {      
        Double.Parse(val)
    }

range_operator_exp<TermRangeNode>
  = '[' _* term_min:range_unquoted_term delim:range_delimiter_exp term_max:range_unquoted_term _* ']'
    {
        new TermRangeNode {
            Min = term_min,
            Max = term_max,
            MinInclusive = true,
            MaxInclusive = true,
            Delimiter = delim
        }
    }
  / '{' _* term_min:range_unquoted_term delim:range_delimiter_exp term_max:range_unquoted_term _* '}'
    {
        new TermRangeNode {
            Min = term_min,
            Max = term_max,
            MinInclusive = false,
            MaxInclusive = false,
            Delimiter = delim
        }
    }
  / '{' _* term_min:range_unquoted_term delim:range_delimiter_exp term_max:range_unquoted_term _* ']'
    {
        new TermRangeNode {
            Min = term_min,
            Max = term_max,
            MinInclusive = false,
            MaxInclusive = true,
            Delimiter = delim
        }
    }
  / '[' _* term_min:range_unquoted_term delim:range_delimiter_exp term_max:range_unquoted_term _* '}'
    {
        new TermRangeNode {
            Min = term_min,
            Max = term_max,
            MinInclusive = true,
            MaxInclusive = false,
            Delimiter = delim
        }
    }
  / '>=' _* term_min:range_unquoted_term
    {
        new TermRangeNode {
            Min = term_min,
            MinInclusive = true,
            Operator = ">="
        }
    }
  / '>' _* term_min:range_unquoted_term
    {
        new TermRangeNode {
            Min = term_min,
            MinInclusive = false,
            Operator = ">"
        }
    }
  / '<=' _* term_max:range_unquoted_term
    {
        new TermRangeNode {
            Max = term_max,
            MaxInclusive = true,
            Operator = "<="
        }
    }
  / '<' _* term_max:range_unquoted_term
    {
        new TermRangeNode {
            Max = term_max,
            MaxInclusive = false,
            Operator = "<"
        }
    }

range_delimiter_exp
  = _+ 'TO' _+
  / _* '..' _*

operator_exp<GroupOperator>
  = _* op:operator _+
    {
        op
    }
  / _* op:operator EOF
    {
        op
    }

operator<GroupOperator> -lexical
  = "AND" _+ "NOT" { GroupOperator.AndNot }
  / "OR" _+ "NOT"{ GroupOperator.OrNot }
  / "OR" { GroupOperator.Or }
  / "AND"{ GroupOperator.And }
  / "NOT"{ GroupOperator.Not }
  / "||" { GroupOperator.Or }
  / "&&" { GroupOperator.And }

prefix_operator_exp
  = _* op:prefix_operator
    {
        op
    }

prefix_operator -lexical
  = '+'
  / '-'

_
  = [ \t\r\n\f]+

EOF
  = !.
